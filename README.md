# Порівняння Жадібного Алгоритму та Динамічного Програмування для Задачі про Решту

У цьому дослідженні ми порівняли два підходи для вирішення задачі видачі решти монетами: жадібний алгоритм та динамічне програмування (ДП).

## Жадібний алгоритм (`find_coins_greedy`)

### Принцип роботи
Жадібний алгоритм на кожному кроці робить локально оптимальний вибір. Для задачі про решту це означає, що він завжди намагається взяти монету найбільшого можливого номіналу, яка не перевищує залишок суми.

### Ефективність
-   **Часова складність: O(k)**, де `k` — кількість номіналів монет. Оскільки кількість номіналів є сталою, складність можна вважати **O(1)** (константною). Алгоритм виконує лише один прохід по масиву монет.
-   **Просторова складність: O(k)** для зберігання результату, що також є константою.

### Недоліки
Основний недолік жадібного підходу полягає в тому, що він **не завжди знаходить оптимальне рішення** (тобто мінімальну кількість монет) для довільного набору номіналів. Наприклад, для номіналів `[1, 4, 5]` та суми `8`, жадібний алгоритм видасть `5 + 1 + 1 + 1` (4 монети), тоді як оптимальним рішенням є `4 + 4` (2 монети).

Однак для стандартного набору монет, який використовується в Україні `[50, 25, 10, 5, 2, 1]`, жадібний алгоритм **завжди** дає оптимальний результат.

## Динамічне програмування (`find_min_coins`)

### Принцип роботи
Алгоритм динамічного програмування розв'язує задачу "знизу вгору". Він обчислює оптимальне рішення для кожної суми від `1` до заданої, зберігаючи проміжні результати. Для кожної суми `S` він перебирає всі монети і знаходить, яке рішення (`1 + рішення для суми S-coin`) буде найкращим.

### Ефективність
-   **Часова складність: O(amount * k)**, де `amount` — цільова сума, а `k` — кількість номіналів. Час виконання лінійно залежить від суми, яку потрібно видати.
-   **Просторова складність: O(amount)**, оскільки потрібно зберігати масиви для проміжних результатів розміром `amount + 1`.

### Переваги
Головна перевага ДП — він **гарантовано знаходить оптимальне рішення** для будь-якого набору номіналів монет.

## Порівняння та Висновки

| Характеристика          | Жадібний алгоритм                   | Динамічне програмування         |
| ----------------------- | ----------------------------------- | ------------------------------- |
| **Швидкість**           | Дуже висока, **O(k)** (не залежить від суми) | Залежить від суми, **O(amount * k)** |
| **Використання пам'яті** | Мінімальне, **O(k)**                | Високе, **O(amount)**           |
| **Оптимальність**       | Не завжди (лише для канонічних наборів) | **Завжди** знаходить оптимум   |

**Висновки:**

-   Для **великих сум** жадібний алгоритм є значно ефективнішим. Його час виконання практично миттєвий і не залежить від величини суми, тоді як час роботи та вимоги до пам'яті для ДП лінійно зростають, що може стати проблемою.
-   **Жадібний алгоритм** є ідеальним вибором, якщо ми працюємо зі стандартним (канонічним) набором монет, для якого він гарантовано дає оптимальний результат. Це наш випадок.
-   **Динамічне програмування** слід використовувати тоді, коли набір номіналів монет довільний, і є вимога знайти гарантовано оптимальне (за кількістю монет) рішення, навіть якщо це потребуватиме більше часу та пам'яті.
